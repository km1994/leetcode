#  79. 单词搜索

## 题目描述

    给定一个二维网格和一个单词，找出该单词是否存在于网格中。

    单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

## 示例:
```
  	示例:

    board =
    [
        ['A','B','C','E'],
        ['S','F','C','S'],
        ['A','D','E','E']
    ]

    给定 word = "ABCCED", 返回 true
    给定 word = "SEE", 返回 true
    给定 word = "ABCB", 返回 false
     

    提示：

        board 和 word 中只包含大写和小写英文字母。
        1 <= board.length <= 200
        1 <= board[i].length <= 200
        1 <= word.length <= 10^3
```

## 思路介绍

### 方法一 回溯法

#### 基本介绍

#### 思路

1. 定义 一个 二维网络 bool board_flag 用于 记录 走过 的 路径；
2. 当前位置向四个方向进行行走，并做以下判断：
   1. 该方向是否走过；
   2. 该方向的 值 是否 和 word[0] 相同，不同需要剪枝；
   3. 是否越界
3. 若 满足 以上 三个 条件，则 往该方向 行走，并 比较 word[1:]，否则剪枝；
4. 当 word 长度 为 零，表示找到结果，返回；
   
#### 复杂度计算

> 时间复杂度：O(n*n*logn)

> 空间复杂度：O(n*m)

