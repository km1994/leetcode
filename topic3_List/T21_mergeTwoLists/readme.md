# 136. 只出现一次的数字

## 题目描述

编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

    每行中的整数从左到右按升序排列。
    每行的第一个整数大于前一行的最后一个整数。

## 示例:
```
    输入:
        matrix = [
          [1,   3,  5,  7],
          [10, 11, 16, 20],
          [23, 30, 34, 50]
        ]
        target = 3
    输出: true
    示例 2:

    输入:
        matrix = [
          [1,   3,  5,  7],
          [10, 11, 16, 20],
          [23, 30, 34, 50]
        ]
        target = 13
    输出: false
```

## 思路介绍

### 方法一：利用二分类方法

#### 题目解析

1. 因为题目给定的矩阵，如果按列 展开，会发现其是一个有序的数组；
2. 题目要求 查找 目标值是否存在于 数组中，所以是一个查找问题；
3. 所以该题类似一个 二分查找问题


#### 思路

1. 求出 矩阵 的 行 和 列；
2. 定义 左边指针 和 右边 指针
3. 定义一个 中间 索引 mid  和 对应值 mid_val
4. 如果 left <= right
   1. 计算 mid = math.floor((left+right)/2)   # 这里需要注意，python 并没有强制转换机制，所以需要自己 做 四舍五入
   2. 计算 mid_val = matrix[math.floor(mid/col)][mid%col] 
   3. 若 mid_val == 目标值，则表示找到；
   4. 若 mid_val < 目标值，表示 目标值 在 右半边，left = mid + 1
   5. 若 mid_val > 目标值，表示 目标值 在 左半边，right = mid - 1
5. 若 left > right，未找到值
   
#### 复杂度计算

> 时间复杂度：O(n*m)  

> 空间复杂度：O(1)  

