# 2020/4/4
`topic` 链表

>   复杂度格式: 时间复杂度, 空间复杂度

### `leetcode21`: 合并两个有序链表
* 最优解: O(m+n), O(1):
    新建链表,同时遍历两个链表并将较小的结点插入新链表。
    直到一个链表遍历完成，然后将另一个链表剩余的部分接到新链表的末尾。

### `leetcode141`: 环形链表

*   最优解: O(n), O(1)两个在操场上快跑慢跑的人一定会相遇。
  快慢指针。只能输出是否相遇，不能输出具体位置。
*   其他: 
    1.  哈希表。 O(n), O(n)。使用一个哈希表存放已遍历的节点地址，如果发现当前地址已存在则返回true。

### `leetcode160`: 相交链表

*   最优解: O(n+m) O(1) 
  
    1.  A链表走到尾结点的时候从B链表头开始走，直到相交的地方他们重叠。
    
        i, j 
    
    2.  将较长的链表头部多出来的部分切掉，设置两个指针同时遍历两个链表，判断结点是否相同。O(max(n, m))
    
        ​    1->2>3->4   m		a+c
        ​     5->3->4       n		 b+c
*   其他:
    1.  哈希/字典 O(n+m), O(n)将a中的元素存放在字典中，遍历链表b，查找元素在a中是否存在。
    2.  栈 O(n+m), O(n+m) : 使用两个栈存储两个链表的结点，然后循环取栈顶元素进行比较，若两结点不相等，则上次pop出来的结点就是相交点。

### `leetcode234`: 回文链表

*   最优解: O(n), O(1) 
    反转半个链表，并比较前半个和后半个链表。

    1->2->3->3->2->1
    1->2->3-><-3<-2<-1
    ↑								  ↑

    1->2->3<-2<-1

    需要加锁。
    
*   其他: 

    1.   用O(n)的其他数据结构存储链表。

### 怎样查找单个链表的中间元素

*   最优解: O(n), O(1): 快慢指针。

*   其他:

    1.  用O(n)的其他数据结构存储链表。

    ### 