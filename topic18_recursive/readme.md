# 递归算法

## 1 算法定义

- 递归算法：直接或者间接的调用自身的算法；
- 递归函数：用函数自身给出定义的函数；
- 递归出口：递归的终止条件；
- 递归体：$f(n)$的值与$f(n-1)$的值之间的关系。

通常，一个递归模型是由递归出口和递归体两部分构成，前者确定递归到何时结束，后者确定递归求解时的递推关系。

## 2 算法思想 

递归算法中一个模块（函数、过程）除了可调用其他模块（函数、过程）外，还可以直接或间接地调用自身。递归是一种比迭代更强、更有用的结构。他把一个复杂的大问题层层转化为一个个与原问题相似的简单的小问题，然后逐步求解小问题，最后通过回溯法得到原问题的解。

## 3 算法求解步骤

- 分析问题、寻求递归：找到递归方程式；
- 设置边界、控制递归：找到递归终止条件，即算法易解的最小规模问题；
- 设计函数，确定参数。

## 4 优缺点

### 4.1 优点

使用递归算法往往使函数的定义和算法的描述简洁清晰易于理解，可读性更好。比如，一个人可以轻易写出前中后序的二叉树遍历算法，但是要写出相应的非递归算法却是一件比较难实现的事情。

### 4.2 缺点

递归算法代码简单，但是正是由于递归过程增加了时间和空间的开销，使得递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多。

### 5 解决方法

因为递归过程增加了时间和空间的开销，使得我们在实际使用中，会尽可能的消除递归，所以有了将递归翻译成迭代过程的一组规则。翻译主要是将递归过程中出现递归调用的地方，用等价的非递归代码来代替，并对return语句作适当处理。这组规则是：

1) 在算法的开始部分，插入说明为栈的代码并将其初始化为空。在一般情况下，这个栈用来存放参数、局部变量和函数的值，每次递归调用的返回地址也要存入栈；
   
2) 将标号$L_i$附于第一条可执行语句。然后，对于每一处递归调用都用一组执行下列规则的指令来代替；
   
3) 将所有参数和局部变量的值存入栈，栈顶指针可作为一个全程变量来看待；
   
4) 建立第$i$个新指标$L_i$，并将$i$存入栈。这个标号的$i$值将用来计算返回地址。此标号放在规则（7）所描述的程序段中；
   
5) 计算这次调用的各实在参数的值，并把这些值赋给相应的形式参数；
   
6) 插入一条无条件转向语句过程的开始部分；
   
7) 如果这过程是函数，则对递归过程中含有此次函数调用的那条语句作如下处理：将该语句的此次函数调用部分从栈顶取回该函数值的代码来代替，其余部分的代码按原描述方式照抄，并将（4）中建立的标号附于这条语句。如果此过程不是函数，则将（4）中建立的标号附于（6）所产生的转移语句后面的那条语句；
   
8) 以上步骤是消去过程中各处的递归调用，现在对递归过程中出现的return进行处理。在每个有return语句的地方，执行如下规则：
   
9)  如果栈为空，这正常返回；
    
10) 否则，将所有输出参数的当前值赋给栈顶上相应的变量；
    
11) 如果栈中有返回地址标号的下标，就插入一条此下标从栈中退出的代码，并把这个下标值赋给一个未使用的变量；
    
12) 从栈中退出所有局部变量和参数的值并把他们赋值于对应的变量；
    
13) 如果这个过程是函数，则插入以下指令，这些指令用来计算紧接在return 后面的表达式并将结果值存在栈顶；
    
14) 用返回地址标号的下标实现对该标号的转向。
在一般情况下，使用下述规则都可以将一个直接递归过程正确地翻译成与之等价的只使用迭代的过程。它的效率通常比原递归模型要高，进一步简化这个程序可使用算法的效率改进。